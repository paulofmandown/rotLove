{"name":"Rotlove","tagline":"Love2D port of rot.js","body":"rotLove is mostly a direct port of rot.js. I love roguelikes and love2D, and (being a beginner struggling to break in to intermediacy) I thought it would be fun to create something that duplicated the functionality found in libtcod and rot.js.\r\n\r\nFollowing are some simple examples of a few of the classes available with rotLove. I'll be adding more here as I get time, but for now I've included a [demos branch](https://github.com/paulofmandown/rotLove/tree/demos) that has examples for every bit of functionality offered.\r\n\r\nDisplay\r\n=========\r\nDisplay started out as rlLove, which itself was a port of [Trystan Spangler's](https://github.com/trystan/) Java-based [Ascii Panel](https://github.com/trystan/AsciiPanel) to Love2D.\r\n\r\nIt is not as robust as rot.js' Display feature, in that is effectively a code page 437 ASCII terminal emulator.\r\n\r\n```lua\r\nROT = require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n  -- create a display object with the following.\r\n    -- Display(widthInCharacters(80), heightInCharacters(24), characterScale(1)\r\n    --         defaultForegroundColor({r=235, g=235, b=235, a=255}),\r\n    --         defaultBackgroundColor({r=15 , g=15 , b=15 , a=255}),\r\n    --         useFullScreen, useVSync, numberOfFsaaSamples (false, false, 0))\r\n    display=ROT.Display:new()\r\n  -- and write some things out.\r\n    local x_position=1\r\n    local y_position=1\r\n    display:write('some string or character', x_position, y_position)\r\n  \r\n  -- or write something to the center\r\n    y_position=5\r\n    display:writeCenter('another string/character', y_position)\r\n    \r\n  -- you can clear the display with:\r\n  -- display:clear()\r\n  \r\n  -- and you can specify an area to clear with:\r\n  -- display:clear(char, x_position, y_position, width, height)\r\n    -- defaults are: ' ', 1, 1, displayWidthInChars, displayHeightInChars\r\nend\r\nfunction love.draw()\r\n    display:draw()\r\nend\r\nfunction love.update() end\r\n```\r\n\r\nString Generator\r\n=========\r\nThe string generator can be given words to learn from, and then provide you with randomly generated words based on what it has learned.\r\n```lua\r\nROT = require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    -- make your display\r\n    frame=ROT.Display:new()\r\n    \r\n    -- now make your string generator\r\n    sg = ROT.StringGenerator:new()\r\n    \r\n    -- read in your names.\r\n    -- where names.txt is a plain-text list of mixed-case names (one per line)\r\n    for name in io.lines('names.txt') do\r\n        -- .observe(string) reads a string and learns from it.\r\n        sg:observe(name)\r\n    end\r\n    \r\n    -- .getStats() will tell you how many distinct characters your string gen will use\r\n                              -- how many different contexts it has seen\r\n                                 -- (i.e.: the context of the letter 'n' in seen is 'see')\r\n                              -- and how many words your string gen has seen\r\n    frame:writeCenter(sg:getStats(), 1)\r\n    \r\n    for i=2,24 do\r\n        -- .generate() will return a random string weighted on the words it has seen with .observe()\r\n        local name = sg:generate()\r\n        frame:writeCenter(name, i)\r\n    end\r\nend\r\nfunction love.update() end\r\nfunction love.draw() frame:draw() end\r\n```\r\n\r\nEventQueue\r\n=========\r\nThe event queue is the base element of all of the schedulers. It can receive any object and feed it back to you when it's turn comes up.\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f=ROT.Display:new()\r\n    -- create the event queue\r\n    q=ROT.EventQueue:new()\r\n    -- use add(object, timeToTurn) to add events\r\n    q:add('e1', 100)\r\n    q:add('e2', 50)\r\n    q:add('e3', 10)\r\n    \r\n    -- remove(object) will remove the next instance of the provided object from the queue\r\n    q:remove('e2')\r\n    \r\n    -- get() returns the next object from the queue\r\n    f:writeCenter(tostring(q:get()), 11)\r\n    f:writeCenter(tostring(q:get()), 12)\r\n    \r\n    -- getTime() returns the number of time units that have passed since the queue was initiated\r\n    f:writeCenter(tostring(q:getTime()), 13)\r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nSimple Scheduler\r\n=========\r\nSimple scheduler is a turn scheduler that takes in objects and returns them in order. It has an additional parameter for repeating events.\r\n\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f=ROT.Display:new()\r\n    s=ROT.Scheduler.Simple:new()\r\n    -- use add to add objects. the second argument (if true) will tell the scheduler to re-insert the event after every turn it gets.\r\n    for i=1,3 do s:add(i, true) end\r\nend\r\nfunction love.update()\r\n    love.timer.sleep(.5)\r\n    -- use next() to get the next event\r\n    f:writeCenter('TURN: '..s:next())\r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nSpeed Scheduler\r\n=========\r\nSpeed Scheduler is a turn scheduler that takes in actors (the player or enemies or other entities that may need to take a turn), and returns them in order based on a speed rating.\r\n\r\nActors provided to the speed scheduler will need to have a .getSpeed() method for retrieving their speed rating.\r\n\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\nclass= require 'vendor/rotLove/vendor/30log'\r\n\r\n-- A simple actor class, implemented with 30log (yonaba.github.io/30log/‎)\r\nactor=class { speed, number }\r\nfunction actor:__init(speed, number)\r\n    self.speed=speed\r\n    self.number=number\r\nend\r\n-- Give your actor class a method called getSpeed that will return a speed rating (where a higher rating is a faster actor).\r\nfunction actor:getSpeed() return self.speed end\r\n\r\nfunction love.load()\r\n    f=ROT.Display()\r\n    rng=ROT.RNG.Twister:new()    -- Using a rng to generate speed values\r\n    rng:randomseed()             -- Seed the rng\r\n    s=ROT.Scheduler.Speed:new()  -- Create the speed scheduler\r\n    for i=1,4 do\r\n        a=actor:new(rng:random(1,100), i)   -- create an actor with random speed and an id (just for demo)\r\n        s:add(a, true)                      -- use .add(actor, repeating) to give the scheduler actors\r\n        \r\n        f:writeCenter('Added '..i..', with speed: '..a:getSpeed(), i)\r\n    end\r\nend\r\ny=5\r\nfunction love.update()\r\n    love.timer.sleep(.5)\r\n    f:writeCenter('TURN: '..s:next().number, y) -- use.next to get your next actor\r\n    y=y<24 and y+1 or 5\r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nAction Scheduler\r\n=========\r\nThe action scheduler is more complex than the other two in that it is based around an actor's action taking a set amount of time to complete before the actor gets another turn.\r\nThis requires that (after fetching the next actor) you tell the scheduler how long his action will take. After you update the scheduler with the current actor's action duration, you can move on and fetch the next actor.\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f  =ROT.Display()\r\n    \r\n    -- Create the action scheduler\r\n    s  =ROT.Scheduler.Action:new()\r\n    \r\n    rng=ROT.RNG.Twister:new()\r\n    rng:randomseed()\r\n    \r\n    -- add some actors, for the action scheduler, you can just provide an id that let's you know whose turn it is.\r\n    for i=1,4 do s:add(i,true,i-1) end\r\nend\r\ny=1\r\nfunction love.update()\r\n    love.timer.sleep(.5)\r\n    \r\n    -- get the next actor (or actor id, whichever you decide is best)\r\n    c  =s:next()\r\n    \r\n    -- get the action's duration\r\n    dur=rng:random(1,20)\r\n    \r\n    -- give the scheduler the current actor's action duration\r\n    s:setDuration(dur)\r\n    \r\n    f:writeCenter('TURN: '..c..' for '..dur..' units of time', y)\r\n    y=y<24 and y+1 or 1\r\nend\r\nfunction love.draw()\r\n    f:draw()\r\nend\r\n```\r\n\r\nMap Generators\r\n==========\r\nRotLove provides 8 different methods for creating a map layout. \r\nOne is a simple arena (everything is floor except the outermost border), three are based on maze algorithms, one is based on a cellular automata method (gives cave-like results), and the last three are more typical room/corridor dungeons.\r\n\r\nWhen creating the map generator, you should provide it with the intended width and height for the map.\r\n\r\nEvery generator is callback based. When calling the generator's create method, you will provide it with a function that will be called for every cell of the level. \r\n\r\nThis function should take three arguments: an x-value, a y-value, and a cell-type value. \r\n\r\nx will be a cell's x-position in the map. \r\ny will be a cell's y-position in the map.\r\nthe cell type will be a 1 or 0 (1 for wall, 0 for floor)\r\n\r\nArena\r\n=========\r\nThe arena map generator returns 1 for all border cells (x==1 or x==mapWidth or y==1 or y==mapHeight).\r\n\r\n```lua\r\nROT=require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f=ROT.Display:new()\r\n    \r\n    -- create the map generator\r\n    -- f:getWidth() returns the width of the terminal in number of characters, getHeight() does the same for height\r\n    m=ROT.Map.Arena:new(f:getWidth(), f:getHeight())\r\n\r\n    -- create the callback that will be provided to the generator's create method    \r\n    function callbak(x,y,val)\r\n        -- In this example we're simply writing a '#' or '.' to the display at the x/y position provided by the create\r\n        f:write(val == 1 and '#' or '.', x, y)\r\n        \r\n        -- another common implementation might store the data in a table to be referenced later.\r\n        -- i.e.: mapTable[x..','..y]=val\r\n    end\r\n\r\n    -- call create and provide the callback\r\n    m:create(callbak)\r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nMazes\r\n=========\r\nThe divided maze generator is based on [the recursive division method.](http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method)\r\n\r\nThe IceyMaze is derived from the rot.js implementation of [this](http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze#Maze_Generator_in_Visual_Basic_6) algorithm.\r\n\r\nIcey is unique in that it takes a third argument (an integer) for regularity, where 0 is the most random.\r\n\r\nThe Eller Maze is based on [Eller's Algorithm](http://homepages.cwi.nl/~tromp/maze.html). It generates a perfect maze (there are no loops and there is one path between any two floor points) and it only requires one row's values to generate the next row.\r\n\r\n```lua \r\nROT=require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    -- Icey and divided work best with odd map width and height.\r\n    f =ROT.Display(81,25)\r\n    \r\n    -- create your callback\r\n    function calbak(x,y,val) f:write(val==1 and '#' or '.', x, y) end\r\n    \r\n    -- create your map generator\r\n        -- divided maze\r\n        dm=ROT.Map.DividedMaze:new(f:getWidth(), f:getHeight())\r\n        -- eller maze\r\n        lr=ROT.Map.EllerMaze:new(f:getWidth(), f:getHeight())\r\n        \r\n        -- Icey Maze - remember you can opt to provide a regularity value here\r\n        ic=ROT.Map.IceyMaze:new(f:getWidth(), f:getHeight(), 0)\r\n    \r\n    -- call create on the generator and provide the callback\r\n    dm:create(calbak)\r\n     -- lr:create(calbak)\r\n     -- ic:create(calbak)\r\n    \r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nCellular\r\n=========\r\nI'll let the rot.js author take this one:\r\n\r\n>Interesting cave systems can be created using ROT.Map.Cellular, a generator which simulates a cellular automaton. Using this generator is a bit more complex, because it offers richer features and is more configurable.\r\n>\r\n>Apart from the traditional width and height arguments, ROT.Map.Cellular accepts also a configuration object with the following optional keys:\r\n>\r\n>born – array of neighbor counts; when an empty cell has this number of neighbors, a new cell is born\r\n>\r\n>survive – array of neighbor counts; when an existing cell has this number of neighbors, it will survive into next iteration\r\n>\r\n>topology – how are neighbors defined: a cell can have four, six or eight neighbors. Six neighbors correspond to the \"hex\" layouting algorithm of ROT.Display.\r\n\r\nFor rotLove this optional config object takes the form of a table.\r\n\r\n```lua\r\nlocal config={born={5,6,7,8}, \r\n              survive ={4,5,6,7,8}, \r\n              topology=8 \r\n             }\r\n```\r\n\r\nUnique to rotLove is that the create method for this generator returns a boolean indicating whether or not a change was made to the map.\r\n\r\nAnd for the full example:\r\n```lua\r\nROT=require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f =ROT.Display()\r\n    cl=ROT.Map.Cellular:new(f:getWidth(), f:getHeight())\r\n    \r\n    -- To start, you need to randomly populate the map\r\n    cl:randomize(.5)\r\n    \r\n    -- because the create method returns true on changes to the map\r\n    -- you can use a while loop to run the create as many times as you possibly can\r\n    -- this usually results in the smoothest possible map\r\n    while cl:create(calbak) do end\r\nend\r\n\r\nfunction love.draw() f:draw() end\r\nfunction calbak(x, y, val) f:write(val==1 and '#' or '.', x, y) end\r\n```\r\n\r\nDungeons\r\n==========\r\nDigger is based on [this](http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm) algorithm designed by Mike Anderson. It uses a random location to build either a room or corridor and continues to do so until it has reached a time limit or has reached a threshold for floor cells.\r\n\r\nUniform sets several rooms down and then tries to connect them together with corridors.\r\n\r\nRogue is based on the original map algorithm used by Rogue.\r\n\r\nDigger and Uniform can both take a third options argument. The table takes the following form:\r\n```lua\r\noptions={roomWidth={3,8},\r\n         roomHeight={3,5},\r\n         corridorLength={3,7},\r\n         dugPercentage=0.2,\r\n         timeLimit=1000\r\n        }\r\n```\r\n\r\nDigger usually results in a lot of dead-end corridors. That's not my intention for it, but I haven't been able to correct that behavior, yet. With that in mind, Digger's option table can have another element called nocorridorsmode. When options.nocorridorsmode is true, the generator only uses rooms to build the map.\r\n\r\n```lua\r\nfunction love.load()\r\n    f=ROT.Display()\r\n    options={nocorridorsmode=true}\r\n    dgr=ROT.Map.Digger(f:getWidth(), f:getHeight(), options)\r\n    uni=ROT.Map.Uniform(f:getWidth(), f:getHeight())\r\n    rog=ROT.Map.Rogue(f:getWidth(), f:getHeight())\r\n    dgr:create(calbak) -- or rog:create(calbak) or uni:create(calbak)\r\nend\r\nfunction love.draw() f:draw() end\r\nfunction calbak(x, y, val) f:write(val==1 and '#' or '.', x, y) end\r\n```\r\n\r\nNoise Generation\r\n=========\r\nNoise generation can be used for lots of things (from map generation to enemy/item population). rot.js has a simplex noise generator that I ported over.\r\n\r\n```lua\r\nROT=require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    -- If you're interested in noise generation and haven't taken the time to peruse the source, yet,\r\n    -- this is a good time to point out that display takes a good bit of arguments.\r\n    -- Check out the source for a full list.\r\n    -- Here is an example of setting the width, height, and scale arguments.\r\n    -- width=256, height=100, and all tiles will be scaled down to 27.5% of their normal size.\r\n    f=ROT.Display(256, 100, .275)\r\n    \r\n    -- instantiate the Simplex generator.\r\n    sim=ROT.Noise.Simplex()\r\n    \r\n    -- you'll to make your own loop here, ROT.Noise is not callback-based.\r\n    for j=1,f:getHeight() do\r\n        for i=1,f:getWidth() do\r\n            -- get will return your value when provided with an x,y position\r\n            local val=sim:get(i/20, j/20)*255\r\n            red  =math.floor(val>0 and val or 0)\r\n            green=math.floor(val<0 and -val or 0)\r\n\r\n            f:write(' ', i, j, nil, {r=red, g=green, b=0, a=255})\r\n        end\r\n    end    \r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nField of View\r\n=========\r\nProvided with rotLove are two fov calculating algorithms.\r\nEach requires two callbacks. One for determining whether a tile is passable, and one that is used when determining whether a tile is in sight.\r\n\r\nBresenham - Ray Casting\r\n=========\r\nThis is a very straight-forward Ray Casting implementation. A number of lines are cast from the center point, and we stop calling the callback when an impassable tile is reached.\r\n\r\nIt's considerably slower than shadow casting because tiles close to center are checked many times.\r\n\r\nPrecise Shadow Casting\r\n=========\r\nPrecise was built using [this](http://www.roguebasin.roguelikedevelopment.org/index.php?title=Precise_Shadowcasting_in_JavaScript) algorithm from rot.js.\r\nIt's very quick and awesome, and I highly suggest using it over bresenham.\r\n\r\nIt stores a set of arcs for each shadow around the center, so each tile is only ever checked once.\r\n\r\n```lua\r\nROT=require 'vendor/rotLove/rot'\r\n\r\nfunction love.load()\r\n    player={x=1, y=1}\r\n    f  =ROT.Display()\r\n    -- This will store the map data for later reference\r\n    map={}\r\n    mapgen=ROT.Map.Uniform:new(f:getWidth(), f:getHeight())\r\n    mapgen:create(calbak)\r\n    \r\n    -- Build the fov calculator\r\n    fov=ROT.FOV.Bresenham:new(lightCalbak)  -- or fov=ROT.FOV.Precise:new(lightCalbak)\r\n    -- determine a center point for the field\r\n    placePlayer()\r\n    -- and run the computeCallback on the viewable tiles\r\n    fov:compute(player.x, player.y, 10, computeCalbak)\r\nend\r\n\r\n-- This will be the callback for map generation\r\nfunction calbak(x, y, val)\r\n    map[x..','..y]=val\r\n    defaultForeground={r=110, g=110, b=110, a=255} -- color for out of view tiles\r\n    defaultBackground={r=0, g=0, b=0, a=255}       -- background color for out of view tiles\r\n    f:write(val==1 and '#' or '.', x, y, defaultForeground, defaultBackground)\r\nend\r\n\r\n-- This will be the callback to determine whether tiles are passable\r\nfunction lightCalbak(fov, x, y)\r\n    local key=x..','..y\r\n    if map[key] then\r\n        return map[key]==0\r\n    end\r\n    return false\r\nend\r\n\r\n-- This will be the callback used on every cell within view.\r\nfunction computeCalbak(x, y, r, v)\r\n    local key  =x..','..y\r\n    if not map[key] then return end\r\n    local color= {r=121, g=121, b=0, a=255}\r\n    f:write(r>0 and f:getCharacter(x, y) or '@', x, y, nil, color)\r\nend\r\n\r\n-- This is just for the demo, it will place the player (center of fov) in a random passable cell.\r\nfunction placePlayer()\r\n    local key =nil\r\n    local char='#'\r\n    local rng=ROT.RNG.Twister:new()\r\n    rng:randomseed()\r\n    while true do\r\n        key=rng:random(1,f:getWidth())..','..rng:random(1,f:getHeight())\r\n        if map[key]==0 then\r\n            pos = key:split(',')\r\n            player.x, player.y=tonumber(pos[1]), tonumber(pos[2])\r\n            f:write('@', player.x, player.y)\r\n            break\r\n        end\r\n    end\r\nend\r\n\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nColor \r\n=========\r\nColor is a basic color toolset. It can generate usable colors from strings, add/multiply/interpolate multiple colors, and it also provides ~140 colors to start.\r\n\r\n```lua\r\nfunction love.load()\r\n\tf=ROT.Display:new()\r\n\tcolorHandler=ROT.Color:new()\r\n\t-- build a color from a string\r\n    c[1]=colorHandler:fromString('rgb(10, 128, 230)')   -- js style rgb\r\n    c[2]=colorHandler:fromString('#faa')\t\t\t\t-- 3-character hex\r\n    c[3]=colorHandler:fromString('#83fcc4') \t\t\t-- 6-character hex\r\n    c[4]=colorHandler:fromString('goldenrod')\t\t\t-- a color name defined by ROT.Color\r\n\r\n    -- Explicitly define a color object - This is how all elements of rotLove see colors\r\n    c[5]={r=51,g=102,b=51,a=255}\r\n\r\n    -- add multiple colors. first argument is a base color, the second argument can be one color or a table of colors\r\n    c[6]=colorHandler:add({r=10,g=128,b=230,a=255}, {{r=200,g=10,b=15,a=255},{r=30,g=30,b=100,a=255}})\r\n    \r\n    -- multiply multiple colors\r\n    c[7]=colorHandler:multiply(colorHandler:fromString('goldenrod'),\r\n                             {colorHandler:fromString('lightcyan'),\r\n                              colorHandler:fromString('lightcoral')})\r\n\r\n\t-- interpolate two colors\r\n    c[8]=colorHandler:interpolate({r=200,g=10,b=15,a=255},{r=30,g=30,b=100,a=255})\r\n    c[9]=colorHandler:interpolateHSL({r=200,g=10,b=15,a=255},{r=30,g=30,b=100,a=255})\r\n\r\n    -- generate a random color from a base color and a set of standard deviations\r\n    c[10]=colorHandler:randomize(colorHandler:fromString('silver'), {30,10,20})\r\n    c[11]=colorHandler:randomize(colorHandler:fromString('silver'), {30,10,20})\r\n    c[12]=colorHandler:randomize(colorHandler:fromString('silver'), {30,10,20})\r\n    c[13]=colorHandler:randomize(colorHandler:fromString('silver'), {30,10,20})\r\n\r\n    c[14]=colorHandler:fromString('silver')\r\n\r\n    i=1\r\nend\r\nfunction love.update() \r\n\tlove.timer.sleep(.5)\r\n\t-- Wipe the screen with one of the colors\r\n\tf:clear(nil, nil, nil, nil, c[i])\r\n\ti=i+1\r\nend\r\n```\r\n\r\nLighting\r\n=========\r\nLighting is probably my favorite thing, ever. With it you can set a light source at a given point with a given color. It will emit light based on a provided FOV. If two lights overlap, their colors will mix together.\r\n\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\n\r\nfunction love.load()\r\n    f=ROT.Display()\r\n\r\n    -- We'll use a color object to mix the light sources with the ambient light.\r\n    colorhandler=ROT.Color:new()\r\n    rng=ROT.RNG.Twister:new()\r\n    rng:randomseed()\r\n\r\n    -- to store map data\r\n    mapData={}\r\n\r\n    -- to store lighting data\r\n    lightData={}\r\n\r\n    -- making a cave\r\n    map= ROT.Map.Cellular:new(f:getWidth(), f:getHeight())\r\n    map:randomize(.5)\r\n    for i=1,5 do map:create(mapCallback) end\r\n    \r\n    -- We'll need an FOV object to pass to lighting\r\n    fov=ROT.FOV.Precise:new(lightPasses, {topology=4})\r\n\r\n    -- get a lighting object\r\n    lighting=ROT.Lighting(reflectivityCB, {range=12, passes=2})\r\n\r\n    -- pass the fov object to lighting\r\n    lighting:setFOV(fov)\r\n\r\n    -- randomly place some lights\r\n    for i=1,5  do\r\n        local point=getRandomFloor()\r\n        f:write('*',tonumber(point[1]),tonumber(point[2]))\r\n        lighting:setLight(tonumber(point[1]),tonumber(point[2]), getRandomColor())\r\n    end\r\n\r\n    -- this will generate the lighting data\r\n    lighting:compute(lightingCallback)\r\n\r\n    -- a default ambient light value for all cells\r\n    local ambientLight={r=100, g=100, b=100, a=255}\r\n\r\n    -- loop through all of the cells\r\n    for k,_ in pairs(mapData) do\r\n    \t-- get the cell position\r\n        local parts=k:split(',')\r\n        local x    =tonumber(parts[1])\r\n        local y    =tonumber(parts[2])\r\n\r\n        -- a base color for wall or floor cells\r\n        local baseColor=mapData[k]>0 and {r=100, g=100, b=100, a=255} or {r=50, g=50, b=50, a=255}\r\n        \r\n        -- mix the lighting values with the default ambient light values\r\n        local light=ambientLight\r\n        if lightData[k] then\r\n            light=colorhandler:add(light, lightData[k])\r\n        end\r\n        \r\n        -- mix the base color of cells with the lighting value\r\n        local finalColor=colorhandler:multiply(baseColor, light)\r\n\r\n        -- if we set a character at this cell earlier, get it\r\n        local char=f:getCharacter(x, y)\r\n\r\n        -- write the light and character to the display\r\n        f:write(char and char or ' ', x, y, nil, finalColor)\r\n    end\r\nend\r\n\r\nfunction love.draw() f:draw() end\r\n\r\nfunction lightingCallback(x, y, color)\r\n    local key=x..','..y\r\n    lightData[x..','..y]=color\r\nend\r\n\r\n-- generate a totally random subtle color\r\nfunction getRandomColor()\r\n    return { r=math.floor(rng:random(0,125)),\r\n             g=math.floor(rng:random(0,125)),\r\n             b=math.floor(rng:random(0,125)),\r\n             a=255}\r\nend\r\n\r\n-- to get a random floor cell\r\nfunction getRandomFloor()\r\n    local key=nil\r\n    while true do\r\n        key=rng:random(1,f:getWidth())..','..rng:random(1,f:getHeight())\r\n        if mapData[key]==1 then\r\n            return key:split(',')\r\n        end\r\n    end\r\nend\r\n\r\n-- floor cells near to a light source can potentially emit light themselves. this callback is passed to the lighting object at creation to assist with that.\r\nfunction reflectivityCB(lighting, x, y)\r\n    local key=x..','..y\r\n    return mapData[key]==1 and .3 or 0\r\nend\r\n\r\n-- to determine if light can pass through a cell\r\nfunction lightPasses(fov, x, y)\r\n    return mapData[x..','..y]==1\r\nend\r\n\r\n-- the standard map callback\r\nfunction mapCallback(x, y, val)\r\n    mapData[x..','..y]=val\r\nend\r\n```\r\n\r\nPath Finding - Dijkstra and AStar\r\n==========\r\nDijkstra was built using a simplified version of [Dijkstra's Algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) where all edges have a length of 1.\r\n\r\nAStar was built using a simplified version of [the A* algorithm](http://en.wikipedia.org/wiki/A*) where all edges have a length of 1.\r\n\r\n```lua \r\nfunction love.load()\r\n    --f=ROT.Display:new()\r\n    rng=ROT.RNG.Twister:new()\r\n    rng:randomseed()\r\n    mapGen=ROT.Map.Uniform(f:getWidth(), f:getHeight())\r\n    \r\n    -- A place to store the map data\r\n    data={}\r\n    \r\n    mapGen:create(mapCallback)\r\n    \r\n    -- Get three random points to path through\r\n    p1=getRandomFloor(data) -- An endpoint\r\n    p2=getRandomFloor(data) -- A Start\r\n    p3=getRandomFloor(data) -- A Start\r\n    \r\n    -- build a path finder providing the endpoint\r\n    astar=ROT.Path.AStar(p1[1], p1[2], passableCallback)\r\n    -- or dkstr=ROT.Path.Dijkstra(p1[1], p1[2], passableCallback)\r\n    \r\n    -- Calculate the path to the endpoint from a point\r\n    astar:compute(p2[1], p2[2], pathCallback)\r\n    astar:compute(p3[1], p3[2], pathCallback)\r\n\r\n    f:write('S', tonumber(p1[1]), tonumber(p1[2]), nil, {r=0, g=0, b=255, a=255})\r\n    f:write('E', tonumber(p2[1]), tonumber(p2[2]), nil, {r=0, g=0, b=255, a=255})\r\n    f:write('E', tonumber(p3[1]), tonumber(p3[2]), nil, {r=0, g=0, b=255, a=255})\r\nend\r\n\r\n-- A callback used on every cell in the calculated path\r\nfunction pathCallback(x, y)\r\n    f:write('.', x, y, nil, {r=136, g=0, b=0, a=255})\r\nend\r\n\r\n-- Callback used to determine whether a cell is passable\r\nfunction passableCallback(x, y) return data[x..','..y]==0 end\r\n\r\n-- A function to get a random floor cell\r\nfunction getRandomFloor(data)\r\n    local key=nil\r\n    while true do\r\n        key=rng:random(1,f:getWidth())..','..rng:random(1,f:getHeight())\r\n        if data[key]==0 then\r\n            return key:split(',')\r\n        end\r\n    end\r\nend\r\n\r\n-- The map generators callback\r\nfunction mapCallback(x, y, val)\r\n    data[x..','..y]=val\r\n    f:write(val==0 and '.' or '#', x, y)\r\nend\r\n```\r\n\r\nThanks for checking this out!\r\n","google":"UA-40653955-1","note":"Don't delete this file! It's used internally to help with page regeneration."}